import React, { useState, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import io from 'socket.io-client';
import AddFriendModal from '../Components/AddFriendModal';
import FriendRequestsModal from '../Components/FriendRequestsModal';
import '../Styles/Main.css';

const Main = () => {
  const navigate = useNavigate();
  const [isAddFriendModalOpen, setIsAddFriendModalOpen] = useState(false);
  const [isRequestsModalOpen, setIsRequestsModalOpen] = useState(false);
  const [socket, setSocket] = useState(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [friends, setFriends] = useState([]);
  const [pendingRequests, setPendingRequests] = useState([]);
  const [selectedFriend, setSelectedFriend] = useState(null);
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');
  const messagesEndRef = useRef(null);
  const [loading, setLoading] = useState(false);

  // Initialize user from localStorage
  const [currentUser] = useState(() => {
    try {
      const user = localStorage.getItem('user');
      return user ? JSON.parse(user) : null;
    } catch (e) {
      return null;
    }
  });

  // Function to load chat history
  const loadChatHistory = async (friendId) => {
    try {
      setLoading(true);
      const token = localStorage.getItem('token');
      const res = await fetch(`/api/chat/${friendId}`, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      const data = await res.json();
      if (res.ok) {
        setMessages(data.messages);
      } else {
        console.error('Failed to load messages:', data);
      }
    } catch (error) {
      console.error('Error loading messages:', error);
    } finally {
      setLoading(false);
    }
  };

  // Function to send a message
  const handleSendMessage = async () => {
    if (!newMessage.trim() || !selectedFriend) return;

    try {
      const token = localStorage.getItem('token');
      const res = await fetch(`/api/chat/${selectedFriend.id}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({ content: newMessage })
      });

      const data = await res.json();
      if (res.ok) {
        setMessages(prev => [...prev, data.message]);
        setNewMessage('');
      }
    } catch (error) {
      console.error('Error sending message:', error);
    }
  };

  // Friend request handlers
  const handleAddFriend = async (email) => {
    try {
      const token = localStorage.getItem('token');
      const res = await fetch('/api/friends/request', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({ recipientEmail: email })
      });

      if (!res.ok) {
        throw new Error('Failed to send friend request');
      }
    } catch (error) {
      console.error('Error sending friend request:', error);
    }
  };

  const handleAcceptRequest = async (requestId) => {
    try {
      const token = localStorage.getItem('token');
      const res = await fetch(`/api/friends/accept/${requestId}`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      if (res.ok) {
        const request = pendingRequests.find(r => r.id === requestId);
        if (request) {
          setFriends(prev => [...prev, request]);
          setPendingRequests(prev => prev.filter(r => r.id !== requestId));
        }
      }
    } catch (error) {
      console.error('Error accepting friend request:', error);
    }
  };

  const handleRejectRequest = async (requestId) => {
    try {
      const token = localStorage.getItem('token');
      const res = await fetch(`/api/friends/reject/${requestId}`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });

      if (res.ok) {
        setPendingRequests(prev => prev.filter(r => r.id !== requestId));
      }
    } catch (error) {
      console.error('Error rejecting friend request:', error);
    }
  };

  // Scroll to bottom when new messages arrive
  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollTop = messagesEndRef.current.scrollHeight;
    }
  }, [messages]);

  // Load chat history when selecting a friend
  useEffect(() => {
    if (selectedFriend) {
      loadChatHistory(selectedFriend.id);
    }
  }, [selectedFriend]);

  // WebSocket setup
  useEffect(() => {
    const token = localStorage.getItem('token');
    if (!token) {
      navigate('/signin');
      return;
    }

    // Connect to WebSocket server
    const backend = process.env.REACT_APP_BACKEND_URL || 'http://localhost:5000';
    const newSocket = io(backend, {
      auth: { token }
    });

    newSocket.on('connect', () => {
      console.log('Connected to WebSocket');
      newSocket.emit('authenticate', token);
    });

    // Listen for new messages
    newSocket.on('message', (data) => {
      if (selectedFriend && data.senderId === selectedFriend.id) {
        setMessages(prev => [...prev, {
          sender: data.senderId,
          recipient: data.recipientId,
          content: data.content,
          timestamp: new Date()
        }]);
      }
    });

    // Listen for friend requests
    newSocket.on('friendRequest', (data) => {
      setPendingRequests(prev => [...prev, data]);
    });

    // Listen for friend request responses
    newSocket.on('friendRequestResponse', (data) => {
      if (data.status === 'accepted') {
        setFriends(prev => [...prev, data.friend]);
      }
    });

    newSocket.on('disconnect', () => {
      console.log('Disconnected from WebSocket');
    });

    setSocket(newSocket);

    // Cleanup on unmount
    return () => {
      if (newSocket) {
        newSocket.close();
      }
    };
  }, [navigate, selectedFriend]);

  // Load friends and pending requests
  useEffect(() => {
    const loadFriendsAndRequests = async () => {
      const token = localStorage.getItem('token');
      if (!token) {
        navigate('/signin');
        return;
      }

      try {
        // Load friends
        const friendsRes = await fetch('/api/friends', {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });
        const friendsData = await friendsRes.json();
        if (friendsRes.ok) {
          setFriends(friendsData.friends);
        }

        // Load pending requests
        const requestsRes = await fetch('/api/friends/requests', {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });
        const requestsData = await requestsRes.json();
        if (requestsRes.ok) {
          setPendingRequests(requestsData.requests);
        }
      } catch (error) {
        console.error('Error loading friends and requests:', error);
      }
    };

    loadFriendsAndRequests();
  }, [navigate]);

  // Filter friends based on search term
  const filteredFriends = friends.filter(friend => 
    friend.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
    friend.email.toLowerCase().includes(searchTerm.toLowerCase())
  );

  return (
    <div className="main-container">
      <div className="sidebar">
        <div className="sidebar-header">
          <h1 className="sidebar-title">Chats</h1>
          <div className="sidebar-actions">
            <button
              className="action-btn"
              onClick={() => setIsAddFriendModalOpen(true)}
              title="Add Friend"
            >
              <svg viewBox="0 0 24 24">
                <path d="M15,14C12.33,14 7,15.33 7,18V20H23V18C23,15.33 17.67,14 15,14M6,10V7H4V10H1V12H4V15H6V12H9V10M15,12A4,4 0 0,0 19,8A4,4 0 0,0 15,4A4,4 0 0,0 11,8A4,4 0 0,0 15,12Z" />
              </svg>
            </button>
            <button
              className="action-btn"
              onClick={() => setIsRequestsModalOpen(true)}
              title="Friend Requests"
            >
              <div className="action-btn-wrapper">
                <svg viewBox="0 0 24 24">
                  <path d="M12 12C14.21 12 16 10.21 16 8C16 5.79 14.21 4 12 4C9.79 4 8 5.79 8 8C8 10.21 9.79 12 12 12ZM12 14C9.33 14 4 15.34 4 18V20H20V18C20 15.34 14.67 14 12 14Z" />
                </svg>
                {pendingRequests.length > 0 && (
                  <span className="badge">{pendingRequests.length}</span>
                )}
              </div>
            </button>
          </div>
        </div>

        <div className="search-container">
          <div className="search-box">
            <svg className="search-icon" viewBox="0 0 24 24">
              <path d="M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z" />
            </svg>
            <input
              type="text"
              placeholder="Search friends..."
              className="search-input"
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
            />
          </div>
        </div>

        <div className="conversations-container">
          {searchTerm && filteredFriends.length === 0 ? (
            <div className="no-results">No friends found</div>
          ) : (
            filteredFriends.map(friend => (
              <div
                key={friend.id}
                className={`conversation-item ${selectedFriend?.id === friend.id ? 'active' : ''}`}
                onClick={() => setSelectedFriend(friend)}
              >
                <div className="conversation-avatar">
                  {friend.avatar ? (
                    <img src={friend.avatar} alt={friend.name} />
                  ) : (
                    <div className="avatar-placeholder">
                      {friend.name.charAt(0).toUpperCase()}
                    </div>
                  )}
                </div>
                <div className="conversation-info">
                  <h3 className="conversation-name">{friend.name}</h3>
                  <p className="conversation-email">{friend.email}</p>
                </div>
              </div>
            ))
          )}
        </div>
      </div>

      <div className="chat-area">
        {selectedFriend ? (
          <>
            <div className="chat-header">
              <div className="chat-header-info">
                <div className="chat-avatar">
                  {selectedFriend.avatar ? (
                    <img src={selectedFriend.avatar} alt={selectedFriend.name} />
                  ) : (
                    <div className="avatar-placeholder">
                      {selectedFriend.name.charAt(0).toUpperCase()}
                    </div>
                  )}
                </div>
                <div className="chat-user-info">
                  <h2 className="chat-username">{selectedFriend.name}</h2>
                  <p className="chat-status">Online</p>
                </div>
              </div>
            </div>

            <div className="messages-container" ref={messagesEndRef}>
              {messages.map((message, index) => (
                <div
                  key={index}
                  className={`message ${message.sender === currentUser.id ? 'sent' : 'received'}`}
                >
                  <div className="message-content">
                    <p>{message.content}</p>
                    <span className="message-time">
                      {new Date(message.timestamp).toLocaleTimeString([], {
                        hour: '2-digit',
                        minute: '2-digit'
                      })}
                    </span>
                  </div>
                </div>
              ))}
            </div>

            <div className="chat-input-container">
              <div className="chat-input-wrapper">
                <input
                  type="text"
                  placeholder="Type a message..."
                  value={newMessage}
                  onChange={(e) => setNewMessage(e.target.value)}
                  onKeyPress={(e) => {
                    if (e.key === 'Enter' && newMessage.trim()) {
                      handleSendMessage();
                    }
                  }}
                  className="chat-input"
                />
                <button
                  className="send-button"
                  onClick={handleSendMessage}
                  disabled={!newMessage.trim()}
                >
                  <svg viewBox="0 0 24 24">
                    <path d="M2,21L23,12L2,3V10L17,12L2,14V21Z" />
                  </svg>
                </button>
              </div>
            </div>
          </>
        ) : (
          <div className="no-chat-selected">
            <div className="no-chat-content">
              <svg viewBox="0 0 24 24">
                <path d="M20,2H4A2,2 0 0,0 2,4V22L6,18H20A2,2 0 0,0 22,16V4A2,2 0 0,0 20,2M6,9H18V11H6M14,14H6V12H14M18,8H6V6H18" />
              </svg>
              <h2>Select a friend to start chatting</h2>
              <p>Choose from your friends list or add new friends to chat with</p>
            </div>
          </div>
        )}
      </div>
      
      <AddFriendModal
        isOpen={isAddFriendModalOpen}
        onClose={() => setIsAddFriendModalOpen(false)}
        onAddFriend={handleAddFriend}
      />
      
      <FriendRequestsModal
        isOpen={isRequestsModalOpen}
        onClose={() => setIsRequestsModalOpen(false)}
        requests={pendingRequests}
        onAcceptRequest={handleAcceptRequest}
        onRejectRequest={handleRejectRequest}
      />
    </div>
  );
};

export default Main;